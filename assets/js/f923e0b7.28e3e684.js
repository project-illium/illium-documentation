"use strict";(self.webpackChunkillium_documentation=self.webpackChunkillium_documentation||[]).push([[8310],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=l(n),d=r,k=m["".concat(c,".").concat(d)]||m[d]||u[d]||i;return n?a.createElement(k,o(o({ref:t},p),{},{components:n})):a.createElement(k,o({ref:t},p))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[m]="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3022:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:4,description:"Examples of basic scripts"},o="Locktime",s={unversionedId:"developers/locktime",id:"developers/locktime",title:"Locktime",description:"Examples of basic scripts",source:"@site/docs/developers/locktime.md",sourceDirName:"developers",slug:"/developers/locktime",permalink:"/developers/locktime",draft:!1,editUrl:"https://github.com/project-illium/illium-documentation/docs/developers/locktime.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,description:"Examples of basic scripts"},sidebar:"devSidebar",previous:{title:"Scripts",permalink:"/developers/scripts"},next:{title:"Covenants",permalink:"/developers/covenants"}},c={},l=[{value:"Relative Locktime",id:"relative-locktime",level:2}],p={toc:l},m="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"locktime"},"Locktime"),(0,r.kt)("p",null,"In this section we're going to talk about how time is used in illium transactions. "),(0,r.kt)("p",null,"In a perfect world the timestamp of the block containing the transaction would be passed in to the unlocking script as a\nparameter. The problem here we often need to validate transactions twice \u2015 once when they enter the mempool and again when\nthey enter a block, and we simply don't know the block timestamp at the point when the transaction enters the mempool. "),(0,r.kt)("p",null,"Other blockchains get around this problem by just not validating transactions when they enter the mempool, instead relying\non gas to prevent flooding. But one of the benefits of illium is we don't have gas fees! So we can't use that approach\nhere."),(0,r.kt)("p",null,"The approach we use is to hard-code a timestamp into a transaction along with a ",(0,r.kt)("inlineCode",{parentName:"p"},"precision")," field. The network then\nadopts a consensus rule that in order to be included in a block, a transaction's timestamp must be within ",(0,r.kt)("inlineCode",{parentName:"p"},"precision")," seconds\nof the block's timestamp."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-protobuf"},"message StandardTransaction {\n    repeated Output outputs =   1;\n    repeated bytes nullifiers = 2;\n    bytes txo_root            = 3;\n    Locktime locktime         = 4;\n    uint64 fee                = 5;\n    bytes proof               = 6;\n}\n\nmessage Locktime {\n    int64 timestamp   = 1;\n    int64 precision = 2;\n}\n")),(0,r.kt)("p",null,"Using this approach, scripts can be sure that the transaction's timestamp is within ",(0,r.kt)("inlineCode",{parentName:"p"},"precision")," seconds of the block's\ntimestamp and can enforce their desired level of precision. This allows scripts to make time based decisions."),(0,r.kt)("p",null,"For example, the timelock script mentioned earlier:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"locking-params = (<lock-until-timestamp> <pubkey>)\nunlocking-params = (<signature>)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(lambda (locking-params unlocking-params input-index private-params public-params)\n        !(import std/crypto/checksig)\n        !(assert (<= !(param locktime-precision) 120))\n        !(assert (> !(param locktime) (car locking-params))\n        !(assert (checksig unlocking-params (cdr locking-params) !(param sighash)))\n        t\n)\n")),(0,r.kt)("h2",{id:"relative-locktime"},"Relative Locktime"),(0,r.kt)("p",null,"Sometimes you want your script to take an action if a certain amount of time has passed since the last transaction. "),(0,r.kt)("p",null,"This can be done in illium scripts by encoding the current timestamp into the state field, then having the subsequent\ntransaction read this timestamp from the input state and compare its own timestamp."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"locking-params = (<relative-timelock> <pubkey>)\nunlocking-params = (<signature>)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(lambda (locking-params unlocking-params input-index private-params public-params)\n        !(assert (<= !(param locktime-precision) 120))\n        !(assert (> !(param locktime) (+ (car locking-params) !(param priv-in input-index state))))\n        !(assert (checksig unlocking-params (cdr locking-params) !(param sighash)))\n        t\n)\n")),(0,r.kt)("p",null,"Note: the above examples assumes the input state is the previous transaction's locktime. This script (or another script)\nwould likely need to enforce that state was set correctly to make this secure."))}u.isMDXComponent=!0}}]);