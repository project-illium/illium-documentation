"use strict";(self.webpackChunkillium_documentation=self.webpackChunkillium_documentation||[]).push([[7660],{3905:(t,e,n)=>{n.d(e,{Zo:()=>u,kt:()=>h});var r=n(7294);function a(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){a(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,r,a=function(t,e){if(null==t)return{};var n,r,a={},o=Object.keys(t);for(r=0;r<o.length;r++)n=o[r],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(r=0;r<o.length;r++)n=o[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}var c=r.createContext({}),p=function(t){var e=r.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},u=function(t){var e=p(t.components);return r.createElement(c.Provider,{value:e},t.children)},d="mdxType",l={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},m=r.forwardRef((function(t,e){var n=t.components,a=t.mdxType,o=t.originalType,c=t.parentName,u=s(t,["components","mdxType","originalType","parentName"]),d=p(n),m=a,h=d["".concat(c,".").concat(m)]||d[m]||l[m]||o;return n?r.createElement(h,i(i({ref:e},u),{},{components:n})):r.createElement(h,i({ref:e},u))}));function h(t,e){var n=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var c in e)hasOwnProperty.call(e,c)&&(s[c]=e[c]);s.originalType=t,s[d]="string"==typeof t?t:a,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5827:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var r=n(7462),a=(n(7294),n(3905));const o={sidebar_position:6,description:"Examples of smart contracts"},i="Smart Contracts",s={unversionedId:"developers/smart-contracts",id:"developers/smart-contracts",title:"Smart Contracts",description:"Examples of smart contracts",source:"@site/docs/developers/smart-contracts.md",sourceDirName:"developers",slug:"/developers/smart-contracts",permalink:"/developers/smart-contracts",draft:!1,editUrl:"https://github.com/project-illium/illium-documentation/docs/developers/smart-contracts.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,description:"Examples of smart contracts"},sidebar:"devSidebar",previous:{title:"Covenants",permalink:"/developers/covenants"},next:{title:"Storage",permalink:"/developers/storage"}},c={},p=[{value:"Examples",id:"examples",level:2},{value:"Auction Contract",id:"auction-contract",level:3},{value:"Voting Contract",id:"voting-contract",level:3},{value:"Contracts Interacting With Other Contracts",id:"contracts-interacting-with-other-contracts",level:2}],u={toc:p},d="wrapper";function l(t){let{components:e,...n}=t;return(0,a.kt)(d,(0,r.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"smart-contracts"},"Smart Contracts"),(0,a.kt)("p",null,"We're now in a position to see how we can use the building blocks we've learned about so far to build a full smart contract.\nIn the context of the illium protocol a smart contract is a recursive script deployed on the network that maintains\nstate, offers methods to the user to read or update that state, and/or transfer coins or tokens according to the rules\ndefined in the code."),(0,a.kt)("p",null,"It should be noted that utxo-based smart contracts are not ",(0,a.kt)("em",{parentName:"p"},"that")," different from account-based system that you're probably\nfamiliar with. "),(0,a.kt)("p",null,"Consider Ethereum as an example:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Contracts are deployed to a specific address."),(0,a.kt)("li",{parentName:"ul"},"This address defines the instance of the contract."),(0,a.kt)("li",{parentName:"ul"},"Each transaction made to the address represents a state transition of the contract."),(0,a.kt)("li",{parentName:"ul"},"Users only need to know the address of the contract to interact with it.")),(0,a.kt)("p",null,"Now compare that to Illium:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Contracts are deployed by sending coins to utxo who's script-hash defines the contract code."),(0,a.kt)("li",{parentName:"ul"},"The outpoint (txid, output-index) of this initial utxo defines the instance of the contract."),(0,a.kt)("li",{parentName:"ul"},"Each linked spend of the utxo represents a state transition of the contract."),(0,a.kt)("li",{parentName:"ul"},"User's need to know data about the most recent utxo in the chain of transactions to interact with the contract.")),(0,a.kt)("p",null,"Outside of that last part about needing to track the most recent utxo, there is very little difference between\nillium and ethereum. And it wouldn't be hard for an IDE to track the utxos for you to remove any mental overhead. "),(0,a.kt)("p",null,"Let's take a look at some examples:"),(0,a.kt)("h2",{id:"examples"},"Examples"),(0,a.kt)("h3",{id:"auction-contract"},"Auction Contract"),(0,a.kt)("p",null,"This contract conducts a basic auction. Before the expiration is reached anyone can bid on the auction by calling\n",(0,a.kt)("inlineCode",{parentName:"p"},"bid()")," method and sending coins into the contract. When they do so the contract enforces a covenant requiring\nthat the previous high bidder be refunded. "),(0,a.kt)("p",null,"The beneficiary of the contract can claim the funds after expiration using the ",(0,a.kt)("inlineCode",{parentName:"p"},"withdraw()")," method. "),(0,a.kt)("p",null,"When ",(0,a.kt)("inlineCode",{parentName:"p"},"bid()")," is called the transaction format is required to be:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Inputs\n======\n0: <this-contract>\n1: <bid>\n2: <fee-paying-input> (optional)\n\nOutputs\n=======\n0: <this-contract>\n1: <prev-bidder-refund>\n2: <change> (optional)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"locking-params = (<auction-expiration> <asset-id> <recipient-pubkey>)\nunlocking-params = (t <bid-amount> <refund-output>)\nor\nunlocking-params = (nil <signature>)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lisp"},"(lambda (locking-params unlocking-params input-index private-params public-params)\n    !(import std/collections/nth)\n    \n    ;; Grab the locktime fields from the public parameters\n    !(def locktime !(param locktime))\n    !(def locktime-precision !(param locktime-precision))\n\n    ;; Assert that the locktime precision is less within the required range.\n    !(assert (<= locktime-precision 60))\n\n    ;; Bid is a method to the contract. It can be called any time prior to \n    ;; expiration to increase the current bid amount.\n    ;;\n    ;; It will also refund the previous high bidder his money.\n    !(defun bid (bid-amount refund-output) (\n        ;; Import the encryption function from the standard library\n        !(import std/crypto/encrypt)\n        !(import std/inputs/script-hash)\n\n        ;; Set a bunch of variables based on the input parameters\n        !(def input-script-hash (script-hash !(param priv-in 0)))\n        !(def state !(param priv-in 0 state))\n        !(def current-bid (car state))\n        !(def prev-bidder-comm (car (cdr state)))\n        !(def asset-id (car (cdr locking-params)))\n        !(def refund-comm (num (commit refund-output)))\n        !(def bid-amount (car (cdr unlocking-params)))\n        !(def new-state !(list bid-amount refund-comm))\n        !(def in-salt !(param priv-in 0 salt))\n        !(def new-salt (num (commit in-salt)))\n        !(def new-output !(list input-script-hash bid-amount asset-id new-salt new-state))\n\n        ;; Assert that input 1's amount is greater than or equal to the bid amount provided\n        ;; in the unlocking params.\n        !(assert (>= !(param priv-in 1 amount) bid-amount))\n        \n        ;; Assert that input 1's asset-id is the same as the one set in the locking-params\n        !(assert (>= !(param priv-in 1 asset-id) asset-id))\n\n        ;; Assert that output 0 is constructed as expected\n        ;; - script-hash is same as the input script-hash (recursion)\n        ;; - amount is equal to the new bid\n        ;; - asset-id is equal to the input asset id\n        ;; - the salt is the hash of the previous salt\n        ;; - the new state is of form (bid-amount bidder-comm)\n        !(assert-eq !(param priv-out 0) new-output)\n\n        ;; Assert that the input 1 amount is greater than the current bid\n        !(assert (> bid-amount current-bid))\n\n        ;; Assert that the bidder's commitment contains the correct amount\n        !(assert-eq bid-amount (nth 1 refund-output))\n\n        ;; Assert that the bidder's commitment contains the correct asset id\n        !(assert-eq asset-id (nth 2 refund-output))\n\n        ;; Assert that the public output 0 ciphertext is equal to the encryption of\n        ;; the new contract output.\n        !(assert-eq !(param pub-out 0 ciphertext) (encrypt new-salt new-output))\n\n        ;; Assert that the tranasction's locktime is less than the auction expiration\n        !(assert (< locktime (car locking-params)))\n        \n        ;; If the current-bid is greater than zero make sure the public output 1 commitment \n        ;; is equal to the prev-bidder-comm. Otherwise we can just return t.\n        (if (current-bid > 0)\n            (= !(param pub-out 1) prev-bidder-comm)\n            t\n        )\n    ))\n\n    ;; Withdraw is another method. It can be used the by the auction beneficiary to withdraw\n    ;; the funds after expiration\n    !(defun withdraw (signature) ( \n        ;; Import the checksig function from the standard library\n        !(import std/crypto/checksig)\n\n        ;; Assert that the tranasction's locktime is greater than or equal to the auction expiration\n        !(assert (>= locktime (car locking-params)))\n\n        ;; Assert that the transaction's sig-hash is signed by the key provided in the locking-params\n        !(assert (checksig signature (cdr (cdr locking-params)) !(param sighash)))\n\n        ;; Return true\n        t\n    ))\n\n    ;; Execute one of the two methods based on the selection in the unlocking params\n    (if (car unlocking-params)\n        (bid (nth 1 unlocking-params) (nth 2 unlocking-params))\n        (withdraw (cdr unlocking-params))\n    )\n)\n")),(0,a.kt)("h3",{id:"voting-contract"},"Voting Contract"),(0,a.kt)("p",null,"This voting contract allows anyone to vote on an issue using their public key.\nThe contract state tracks both the votes and who has already voted, ensuring\nnobody votes twice. "),(0,a.kt)("p",null,"And admin is allowed to close the vote."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"locking-params = (<len-candidates> <admin-pubkey>)\nstate = (<is_open> <db_root> <vote-records>)\n\nunlocking-params = (<method> <vote> <pubkey> <signature> <merkle-proof>)\nor \nunlocking-params = (<method> <signature>)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lisp"},"(lambda (locking-params unlocking-params input-index private-params public-params)\n    ;; Import the encryption and checksig functions from the standard library\n    !(import std/crypto)\n    !(import std/inputs/script-hash)\n    \n    !(defun close-vote () (\n           ;; Verify the admin signature\n           !(assert (checksig (cdr unlocking-params) (cdr (cdr unlocking-params)) !(param sighash)))\n                      \n           ;; Set the vote-open flag to 0      \n           !(def state !(param priv-in input-index state))\n           !(def new-state !(list 0 (cdr state)))\n                            \n           ;; Enforce a covenant making sure the output commitment is computed correctly\n           !(def new-salt (num (commit !(param priv-in intput-index salt))))\n           !(def new-output (num (commit !(list (script-hash !(params priv-in input-index)) 0 !(param priv-in input-index asset-id) new-state new-salt))))\n           !(assert-eq !(priv-out 0) new-output)\n   \n           ;; Enforce that the ciphertext is computed correctly.\n           !(assert-eq (!param pub-out 0 ciphertext) (encrypt new-salt new-output))\n           \n           ;; Return True\n           t\n    ))\n  \n    !(defun vote () (\n        !(import std/merkle-db)\n        !(import std/collections/nth)\n\n        !(defun record-vote (candidate vote-records) (\n            !(def current-votes (nth candidate vote-records))\n            (map-update vote-records candidate (+ current-votes 1))\n        ))\n\n        !(defun make-vote-records (n i records) (\n             (if (< i n)\n                 (make-vote-records n (+ i 1) (cons records (cons 0 nil)))\n                 records\n             )\n        ))\n        \n        !(def state !(param priv-in input-index state))\n\n        !(def vote-records (if (state)\n                                state\n                                (make-vote-records (car locking-params) 1 !(list 0))\n                            ))\n\n        !(def pubkey (nth 1 unlocking-params))\n        !(def merkle-proof (nth 4 unlocking-params))\n        !(def signature (nth 3 unlocking-params))\n        !(def state-root (nth 1 state))\n        \n        ;; Make sure the vote is open\n        !(assert (> (car state) 0))\n        \n        ;; Verify the voter can produce a valid signature\n        !(assert (checksig signature pubkey !(param sighash)))\n\n        ;; Verify this pubkey hasn't voted yet\n        !(assert-eq (db-exists pubkey merkle-proof state-root) nil)  \n              \n        ;; Compute the new state root                   \n        !(def new-state-root (db-put nil pubkey merkle-proof state-root))\n\n        ;; Compute the new state with the recorded vote\n        !(def new-state !(list 1 new-state-root (record-vote (car (cdr unlocking-params)) vote-records)))\n\n        ;; Enforce a covenant making sure the output commitment is computed correctly\n        !(def new-salt (hash !(param priv-in intput-index salt)))\n        !(def new-output !(list (script-hash !(params priv-in input-index)) 0 !(param priv-in input-index asset-id) new-state new-salt))\n        !(assert-eq !(priv-out 0) new-output)\n\n        ;; Enforce that the ciphertext is computed correctly.\n        !(assert-eq (!param pub-out 0 ciphertext) (encrypt new-salt new-output))\n        \n        ;; Return True\n        t\n    ))\n  \n    (if (car unlocking-params)\n        (vote)\n        (close-vote)\n    )\n)\n")),(0,a.kt)("h2",{id:"contracts-interacting-with-other-contracts"},"Contracts Interacting With Other Contracts"),(0,a.kt)("p",null,"Contracts aren't limited to interacting with only their code. Because transactions can have multiple inputs, contracts\ncan call methods in other contracts or even send coins into other contracts. "),(0,a.kt)("p",null,"Let's change the voting example above create a separate voter registration contract:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lisp"},"(lambda (locking-params unlocking-params input-index private-params public-params)\n    !(import std/merkle-db)\n    !(import std/crypto/checksig)\n    !(import std/collections/nth)\n    !(import std/inputs/script-hash)\n    \n    !(def pubkey (car unlocking-params))\n    !(def merkle-proof (nth 2 unlocking-params))\n    !(def signature (nth 1 unlocking-params))\n    !(def state-root (car !(param priv-in input-index state)))\n\n    ;; Verify the voter can produce a valid signature\n    !(assert (checksig signature pubkey !(param sighash)))\n\n    ;; Compute the new state root\n    !(def new-state-root (db-put nil pubkey merkle-proof state-root))\n    \n    ;; If this is the first time contract is used, set the isntance ID\n    ;; to the nullifier. Otherwise load the instance ID from the state.\n    !(def instance-id (if state\n                          (car state)\n                          !(param nullifiers input-index)))\n\n    ;; Enforce a covenant making sure the output commitment is computed correctly\n    !(def new-salt (hash !(param priv-in intput-index salt)))\n    !(def new-state !(list instance-id new-state-root))\n    !(def new-output !(list (script-hash !(params priv-in input-index)) 0 !(param priv-in input-index asset-id) new-state new-salt))\n    !(assert-eq !(priv-out 0) new-output)\n\n    ;; Enforce that the ciphertext is computed correctly.\n    !(assert-eq (!param pub-out 0 ciphertext) (encrypt new-salt new-output))\n\n    ;; Return True\n    t\n)\n")),(0,a.kt)("p",null,"And now let's modify the ",(0,a.kt)("inlineCode",{parentName:"p"},"vote()")," method in our previous contract to verify the voter is registered in the registration\ncontract. We're adding these lines in the method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lisp"},";; Import the get-contract function\n!(import std/contracts)\n\n;; get-contract searches the inputs for an input with\n;; the provided script-commitment and instance-id. \n;; Asserts that the input exists.\n!(def registration-contract (get-contract (nth 2 locking-params) (nth 3 locking-params))\n\n;; Grab the root hash of the registration db from the registration contract\n!(def registration-db-root (car (cdr (nth 5 registration-contract))))\n\n;; Grab the registration db inclusion proof from the unlocking params\n!(def registration-proof (nth 5 unlocking-params))\n\n;; Finally verify the voter's public key exists in the registration contract db.\n!(assert db-exists pubkey registration-proof registration-db-root)\n")))}l.isMDXComponent=!0}}]);