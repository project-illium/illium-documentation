"use strict";(self.webpackChunkillium_documentation=self.webpackChunkillium_documentation||[]).push([[3555],{3905:(t,n,e)=>{e.d(n,{Zo:()=>p,kt:()=>d});var i=e(7294);function a(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function o(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,i)}return e}function r(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?o(Object(e),!0).forEach((function(n){a(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):o(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function u(t,n){if(null==t)return{};var e,i,a=function(t,n){if(null==t)return{};var e,i,a={},o=Object.keys(t);for(i=0;i<o.length;i++)e=o[i],n.indexOf(e)>=0||(a[e]=t[e]);return a}(t,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(i=0;i<o.length;i++)e=o[i],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(a[e]=t[e])}return a}var s=i.createContext({}),l=function(t){var n=i.useContext(s),e=n;return t&&(e="function"==typeof t?t(n):r(r({},n),t)),e},p=function(t){var n=l(t.components);return i.createElement(s.Provider,{value:n},t.children)},c="mdxType",m={inlineCode:"code",wrapper:function(t){var n=t.children;return i.createElement(i.Fragment,{},n)}},h=i.forwardRef((function(t,n){var e=t.components,a=t.mdxType,o=t.originalType,s=t.parentName,p=u(t,["components","mdxType","originalType","parentName"]),c=l(e),h=a,d=c["".concat(s,".").concat(h)]||c[h]||m[h]||o;return e?i.createElement(d,r(r({ref:n},p),{},{components:e})):i.createElement(d,r({ref:n},p))}));function d(t,n){var e=arguments,a=n&&n.mdxType;if("string"==typeof t||a){var o=e.length,r=new Array(o);r[0]=h;var u={};for(var s in n)hasOwnProperty.call(n,s)&&(u[s]=n[s]);u.originalType=t,u[c]="string"==typeof t?t:a,r[1]=u;for(var l=2;l<o;l++)r[l]=e[l];return i.createElement.apply(null,r)}return i.createElement.apply(null,e)}h.displayName="MDXCreateElement"},2344:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>u,toc:()=>l});var i=e(7462),a=(e(7294),e(3905));const o={sidebar_position:6},r="Transaction Validation",u={unversionedId:"overview/transaction-validation",id:"overview/transaction-validation",title:"Transaction Validation",description:"We're now in a position to put it all together.",source:"@site/docs/overview/transaction-validation.md",sourceDirName:"overview",slug:"/overview/transaction-validation",permalink:"/overview/transaction-validation",draft:!1,editUrl:"https://github.com/project-illium/illium-documentation/docs/overview/transaction-validation.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Lurk",permalink:"/overview/lurk"},next:{title:"Smart Contracts",permalink:"/overview/smart-contracts"}},s={},l=[{value:"Illium Transaction Format",id:"illium-transaction-format",level:2},{value:"Proving Transaction Validity",id:"proving-transaction-validity",level:2},{value:"Proving the Commitment Exists",id:"proving-the-commitment-exists",level:3},{value:"Proving Spend Authorization",id:"proving-spend-authorization",level:3},{value:"Proving Amounts are Correct",id:"proving-amounts-are-correct",level:3},{value:"Proving No Double Spends",id:"proving-no-double-spends",level:3}],p={toc:l},c="wrapper";function m(t){let{components:n,...e}=t;return(0,a.kt)(c,(0,i.Z)({},p,e,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"transaction-validation"},"Transaction Validation"),(0,a.kt)("p",null,"We're now in a position to put it all together. "),(0,a.kt)("p",null,"So far we've learned how we use output commitments to avoid revealing\ninformation about a transaction's outputs. But how do we avoid revealing information about the inputs we're spending?"),(0,a.kt)("p",null,"Remember in Bitcoin an input looked like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "inputs": [\n    {\n      "prev_hash": "4dd8bc776abd45aa9df7186966fa0733ad28aeab1bac0860d2316a051e65c6d2",\n      "output_index": 1,\n      "signatue_script": "47304402203b39d75ef932b9192b89dc2ba74e76611f552ef7167e74d55ef5e6822740a8140220063231351174d6c31ca15b7da1d8d60cc8f8a764fd578a9a11c1b564522c512b01210391adc032a6cd78870d5ec400bdecc031344e96364654f1cfedb34fdbd6afaea5",\n    }\n  ]\n}\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"prev_hash")," is the transaction ID of transaction containing the unspent transaction output (UTXO) that we're trying to\nspend. And the ",(0,a.kt)("inlineCode",{parentName:"p"},"output_index")," is the number of the output in that transaction that we're spending. "),(0,a.kt)("p",null,"Additionally, ",(0,a.kt)("inlineCode",{parentName:"p"},"signature_script")," is the signature that proves that we are authorized to spend this UTXO. "),(0,a.kt)("h2",{id:"illium-transaction-format"},"Illium Transaction Format"),(0,a.kt)("p",null,"In illium, transactions look like this when they are sent over the wire (in protobuf):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-protobuf"},"message Transaction {\n    repeated Output outputs =   1;\n    repeated bytes nullifiers = 2;\n    bytes txoc_root           = 3;\n    Locktime locktime         = 4;\n    uint64 fee                = 5;\n    bytes proof               = 6;\n\n    message Output {\n        bytes commitment       = 1;\n        bytes ciphertext       = 2;\n    }\n\n    message Locktime {\n        int64 timestamp = 1;\n        int64 precision = 2;\n    }\n}\n")),(0,a.kt)("p",null,"Every data field (except the proof) will be used as a public input to the transaction validation lurk program. We're\ngoing to use this program to prove the validity of the transaction, in zero-knowledge, and without revealing the private\ninformation about our inputs. "),(0,a.kt)("p",null,"Let's see how we do it."),(0,a.kt)("h2",{id:"proving-transaction-validity"},"Proving Transaction Validity"),(0,a.kt)("h3",{id:"proving-the-commitment-exists"},"Proving the Commitment Exists"),(0,a.kt)("p",null,"The first thing that we need to prove is that the output commitments that our inputs are spending actually exist in\nthe txoc set. Remember that txoc accumulator? We're going to use it here. "),(0,a.kt)("p",null,"Below is an example of what the transaction validation lurk program looks like. Instead of writing it in lurk here we will\nwrite it in Go simply for familiarity. Just remember that in the illium codebase, this is written in lurk."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"\n// This is the private parameters that we will use to\n// prove transaction validity, but we will NOT reveal\n// them publicly to the network.\ntype PrivateParams struct {\n    Inputs []struct{\n        Index            uint64\n        InclusionProof   struct{\n            Hashes      [][]byte\n            Flags       uint64\n        }       \n        Amount           uint64\n        Salt             []byte\n        Script           string\n        LockingParams    [][]byte\n        UnlockingParams  [][]byte\n    }\n    Outputs []struct{\n        ScriptHash []byte\n        Amount     uint64\n        Salt       []byte\n    }\n}\n\n// The public parameters are pulled directly from the\n// body of the transaction.\ntype PublicParams struct {\n    Outputs []struct{\n        Commitment      []byte\n        Ciphertext      []byte\n    }\n    Nullifies [][]byte\n    TxocRoot  []byte\n    Locktime  int64\n    Precision uint64\n    Fee       uint64\n}\n\nfunc ProveTransactionValidity(priv PrivateParams, pub PublicParams) bool {\n    for _, input := range priv.Inputs {\n        scriptCommitment := hash(input.Script)\n        scriptHash := hash(scriptCommitment, input.LockingParams...)\n        commitment := hash(scriptHash, input.Amount, input.Salt)\n        \n        if !ValidateInclusionProof(commitment, input.index, input.InclusionProof, pub.TxocRoot) {\n            return false\n        }\n    }\n    return true\n}\n")),(0,a.kt)("p",null,"What you're seeing above is the lurk program is validating that each input's commitment exists in the set of\nall commitments by validating the merkle inclusion proof that links the commitment to a txoc root for a given block."),(0,a.kt)("p",null,"The user specifies which block's txoc root they want to use for this purpose and include it in the body of their\ntransaction. The only requirement is that the commitment must be in tree represented by the provided root. It's generally\nrecommended that users just select the txoc root at the tip of the chain. Full nodes will verify that the root provided\nin the transaction actually exists in the blockchain when they validate the transaction."),(0,a.kt)("p",null,"Notice what we've done here. The proof created by this lurk program will prove that we're spending a valid commitment that\nexists in the set of all commitments, ",(0,a.kt)("em",{parentName:"p"},"without")," actually revealing the specific commitment to the network."),(0,a.kt)("h3",{id:"proving-spend-authorization"},"Proving Spend Authorization"),(0,a.kt)("p",null,"Next we need to prove that we're actually ",(0,a.kt)("em",{parentName:"p"},"authorized")," to spend this commitment. To do this we will execute the users\nlocking script with the provided unlocking parameters. For a basic transfer the UnlockingParams will usually contain a signature."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"func ProveTransactionValidity(priv PrivateParams, pub PublicParams) bool {\n    for i, input := range priv.Inputs {\n        scriptCommitment := hash(input.Script)\n        scriptHash := hash(scriptCommitment, input.LockingParams...)\n        commitment := hash(scriptHash, input.Amount, input.Salt)\n        \n        if !ValidateInclusionProof(commitment, input.index, input.InclusionProof, pub.TxocRoot) {\n            return false\n        }\n        \n        if !ValidateScript(input.Script, input.LockingParams, input.UnlockingParams, i) {\n            return false\n        }\n    }\n    return true\n}\n")),(0,a.kt)("h3",{id:"proving-amounts-are-correct"},"Proving Amounts are Correct"),(0,a.kt)("p",null,"Next we need to prove that this transaction is spending only the correct amount of coins. If we didn't do this it would\nbe possible for a transaction to create coins out of thin air. "),(0,a.kt)("p",null,"First let's add up the input amounts:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"func ProveTransactionValidity(priv PrivateParams, pub PublicParams) bool {\n    inputTotal := 0\n    for i, input := range priv.Inputs {\n        scriptCommitment := hash(input.Script)\n        scriptHash := hash(scriptCommitment, input.LockingParams...)\n        commitment := hash(scriptHash, input.Amount, input.Salt)\n        \n        if !ValidateInclusionProof(commitment, input.index, input.InclusionProof, pub.TxocRoot) {\n            return false\n        }\n        \n        if !ValidateScript(input.Script, input.LockingParams, input.UnlockingParams, i) {\n            return false\n        }\n        inputTotal += input.Amount\n    }\n    return true\n}\n")),(0,a.kt)("p",null,"Now we can turn to the outputs. Remember that the in the body of the transaction the output amounts are hidden behind\nthe commitment hash. To total up the output amounts we're going to need to provide the output commitment preimages as\nprivate parameters and validate that they do in fact hash to the commitments found in the transaction. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"func ProveTransactionValidity(priv PrivateParams, pub PublicParams) bool {\n    inputTotal := 0\n    for i, input := range priv.Inputs {\n        scriptCommitment := hash(input.Script)\n        scriptHash := hash(scriptCommitment, input.LockingParams...)\n        commitment := hash(scriptHash, input.Amount, input.Salt)\n        \n        if !ValidateInclusionProof(commitment, input.index, input.InclusionProof, pub.TxocRoot) {\n            return false\n        }\n        \n        if !ValidateScript(input.Script, input.LockingParams, input.UnlockingParams, i) {\n            return false\n        }\n        inputTotal += input.Amount\n    }\n    \n    outputTotal := 0\n    \n    for i, output : range priv.Outputs {\n            preimage := append(output.ScriptHash, output.Amount, output.Salt)\n            if !bytes.Equal(pub.Outputs[i].Commitment, hash(preimage)) {\n                    return false\n            }\n            outputTotal += output.Amount\n    }\n    return true\n}\n")),(0,a.kt)("p",null,"Finally, we can verify that the output amount plus the transaction fee does not exceed the input amount. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"func ProveTransactionValidity(priv PrivateParams, pub PublicParams) bool {\n    inputTotal := 0\n    for i, input := range priv.Inputs {\n        scriptCommitment := hash(input.Script)\n        scriptHash := hash(scriptCommitment, input.LockingParams...)\n        commitment := hash(scriptHash, input.Amount, input.Salt)\n        \n        if !ValidateInclusionProof(commitment, input.index, input.InclusionProof, pub.TxocRoot) {\n            return false\n        }\n        \n        if !ValidateScript(input.Script, input.LockingParams, input.UnlockingParams, i) {\n            return false\n        }\n        inputTotal += input.Amount\n    }\n    \n    outputTotal := 0\n    \n    for i, output : range priv.Outputs {\n        preimage := append(output.ScriptHash, output.Amount, output.Salt)\n        if !bytes.Equal(pub.Outputs[i].Commitment, hash(preimage)) {\n            return false\n        }\n        outputTotal += output.Amount\n    }   \n    \n    if outputTotal + pub.Fee > inputTotal {\n        return false\n    }\n    \n    return true\n}\n")),(0,a.kt)("h3",{id:"proving-no-double-spends"},"Proving No Double Spends"),(0,a.kt)("p",null,"If you've made it this far you've probably realized that we've proved that the output commitments that we're spending\nexist in the set of all output commitments. But we don't, as yet, have any way of determining if those commitments\nare unspent. "),(0,a.kt)("p",null,"To do this for each input we will calculate a hash value that we will call a ",(0,a.kt)("inlineCode",{parentName:"p"},"nullifier"),". The nullifier will be derived\nfrom private data in each commitment's preimage. It's calculated such that for each output commitment there is only one\nnullifier, but it's not possible to link the nullifier to a specific commitment without knowing the private data. "),(0,a.kt)("p",null,"These nullifiers will be included in the body of the transaction that gets relayed to the network. "),(0,a.kt)("p",null,"Full nodes will maintain a database of all nullifiers that exist in the chain. Validating new transactions consists of\nverifying that the transaction's nullifiers do ",(0,a.kt)("em",{parentName:"p"},"not")," already exist in the nullifier database. If they do, the transaction\nmust be a double spend and is invalid. "),(0,a.kt)("p",null,"Finally, we need to make sure that the nullifiers included in the transaction are actually calculated correctly otherwise\npeople could just put fake nullifiers in the transaction. "),(0,a.kt)("p",null,"We'll again do this inside the transaction validation lurk program:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"func ProveTransactionValidity(priv PrivateParams, pub PublicParams) bool {\n    inputTotal := 0\n    for i, input := range priv.Inputs {\n        scriptCommitment := hash(input.Script)\n        scriptHash := hash(scriptCommitment, input.LockingParams...)\n        commitment := hash(scriptHash, input.Amount, input.Salt)\n        \n        if !ValidateInclusionProof(commitment, input.index, input.InclusionProof, pub.TxocRoot) {\n            return false\n        }\n        \n        if !ValidateScript(input.Script, input.LockingParams, input.UnlockingParams, i) {\n            return false\n        }\n        inputTotal += input.Amount\n\n        nullifier := hash(input.Index, input.Salt, scriptCommitment, input.LockingParams...)\n        if !bytes.Equal(nullifier, pub.Nullifiers[i]) {\n            return false\n        }\n    }\n    \n    outputTotal := 0\n    \n    for i, output : range priv.Outputs {\n        preimage := append(output.ScriptHash, output.Amount, output.Salt)\n        if !bytes.Equal(pub.Outputs[i].Commitment, hash(preimage)) {\n            return false\n        }\n        outputTotal += output.Amount\n    }\n    \n    if outputTotal + pub.Fee > inputTotal {\n        return false\n    }\n    \n    return true\n}\n")),(0,a.kt)("p",null,"So there you have it! We've managed to prove all of the following in zero knowledge:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"That we are spending an output commitment that exists in the set of all output commitments."),(0,a.kt)("li",{parentName:"ul"},"That this output commitment has not been spent before by any other transaction."),(0,a.kt)("li",{parentName:"ul"},"That we are authorized to spend this commitment."),(0,a.kt)("li",{parentName:"ul"},"That the transaction only spends the correct amount of coins and does not create coins out of thin air.")))}m.isMDXComponent=!0}}]);