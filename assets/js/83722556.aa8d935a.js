"use strict";(self.webpackChunkillium_documentation=self.webpackChunkillium_documentation||[]).push([[9653],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=l(n),d=i,h=u["".concat(p,".").concat(d)]||u[d]||m[d]||o;return n?r.createElement(h,a(a({ref:t},c),{},{components:n})):r.createElement(h,a({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=d;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[u]="string"==typeof e?e:i,a[1]=s;for(var l=2;l<o;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1734:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=n(7462),i=(n(7294),n(3905));const o={sidebar_position:2,description:"Review of transactions concepts"},a="Concept Review",s={unversionedId:"developers/concept-review",id:"developers/concept-review",title:"Concept Review",description:"Review of transactions concepts",source:"@site/docs/developers/concept-review.md",sourceDirName:"developers",slug:"/developers/concept-review",permalink:"/developers/concept-review",draft:!1,editUrl:"https://github.com/project-illium/illium-documentation/docs/developers/concept-review.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,description:"Review of transactions concepts"},sidebar:"devSidebar",previous:{title:"Overview",permalink:"/developers"},next:{title:"Scripts",permalink:"/developers/scripts"}},p={},l=[{value:"Utxos",id:"utxos",level:2},{value:"Output Commitments",id:"output-commitments",level:2}],c={toc:l},u="wrapper";function m(e){let{components:t,...o}=e;return(0,i.kt)(u,(0,r.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"concept-review"},"Concept Review"),(0,i.kt)("p",null,"Unlike most other smart contracting platforms, Illium is an utxo-based cryptocurrency. This design allows us to maximize\nuser privacy but comes a little steeper learning curve. In the future we'll likely have a smart contract IDE that will\nabstract away some of this complexity and deliver a more familiar developer experience, but it's still good to understand\nthe nuts and bolts of the system. "),(0,i.kt)("p",null,"If you've read the illium protocol overview and feel like you have to grasp of how things work you can skip to the next\nsection."),(0,i.kt)("h2",{id:"utxos"},"Utxos"),(0,i.kt)("p",null,"Illium transactions have both inputs and outputs just like Bitcoin. Take a look at the transaction structure (in protobuf):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-protobuf"},"message StandardTransaction {\n    repeated Output outputs =   1;\n    repeated bytes nullifiers = 2;\n    bytes txo_root            = 3;\n    Locktime locktime         = 4;\n    uint64 fee                = 5;\n    bytes proof               = 6;\n}\n\nmessage Output {\n    bytes commitment = 1;\n    bytes ciphertext = 2;\n}\n\nmessage Locktime {\n  int64 timestamp = 1;\n  int64 precision = 2;\n}\n")),(0,i.kt)("p",null,"It's pretty easy to spot the outputs. There's an explicit ",(0,i.kt)("inlineCode",{parentName:"p"},"outputs")," field. However, the inputs are a little less obvious.\nSince we're intentionally trying to hide the information about the inputs there isn't any explicit ",(0,i.kt)("inlineCode",{parentName:"p"},"inputs")," field,\nhowever transactions are required to have one ",(0,i.kt)("inlineCode",{parentName:"p"},"nullifier")," for each input. It's not possible to figure out what the input\nis from the ",(0,i.kt)("inlineCode",{parentName:"p"},"nullifier")," data, but you at least know the number of inputs as it must be the same as the number of nullifiers. "),(0,i.kt)("p",null,'Each input points to an output from a prior transaction. In this sense inputs can be said to "spend" an output from another\ntransaction. '),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Utxos",src:n(1951).Z,width:"1024",height:"768"})),(0,i.kt)("p",null,"Outputs which have been created but not yet spent are called \u2015 unspent transaction outputs or UTXOs."),(0,i.kt)("h2",{id:"output-commitments"},"Output Commitments"),(0,i.kt)("p",null,"Each output commits to a ",(0,i.kt)("inlineCode",{parentName:"p"},"script")," \u2015 a computer program that is used to determine whether the coins are allowed to\nbe spent. "),(0,i.kt)("p",null,"Notice the ",(0,i.kt)("inlineCode",{parentName:"p"},"commitment")," field in the ",(0,i.kt)("inlineCode",{parentName:"p"},"output"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-protobuf"},"message Output {\n    bytes commitment = 1;\n    bytes ciphertext = 2;\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"commitment")," is a hash of the concatenation of five values:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"commitment = hash(scriptHash || amount || assetID || salt || state)\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"scriptHash")," is found inside each illium payment address and senders use it when constructing their outputs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"address = serialize(scriptHash || viewKey)\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"scriptHash")," itself is the hash of a ",(0,i.kt)("inlineCode",{parentName:"p"},"scriptCommitment")," and some user-defined ",(0,i.kt)("inlineCode",{parentName:"p"},"lockingParams"),". "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"scriptHash = hash(scriptCommitment || lockingParams)\n")),(0,i.kt)("p",null,"And finally the ",(0,i.kt)("inlineCode",{parentName:"p"},"scriptCommitment")," is computed as the hash of unlocking script."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"script = `(lambda (locking-params unlocking-params input-index private-params public-params)\n             !(import std/crypto/checksig)\n             (checksig unlocking-params locking-params (car public-params))\n          )`\n\nscriptCommitment = hash(script)          \n")),(0,i.kt)("p",null,"Ultimately illium addresses are a type of Pay-to-Script-Hash (P2SH) address (if you're familiar with that term from Bitcoin)."))}m.isMDXComponent=!0},1951:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/utxo-ce19327f1fd53285c4a6606f38e462fc.jpg"}}]);