"use strict";(self.webpackChunkillium_documentation=self.webpackChunkillium_documentation||[]).push([[6722],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>d});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(r),m=o,d=u["".concat(s,".").concat(m)]||u[m]||h[m]||a;return r?n.createElement(d,i(i({ref:t},p),{},{components:r})):n.createElement(d,i({ref:t},p))}));function d(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:o,i[1]=l;for(var c=2;c<a;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},8817:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var n=r(7462),o=(r(7294),r(3905));const a={sidebar_position:4},i="Merkle Trees",l={unversionedId:"overview/merkle-trees",id:"overview/merkle-trees",title:"Merkle Trees",description:"Bitcoin block headers contain a field called the merkle root. The merkle root is a compact cryptographic representation of",source:"@site/docs/overview/merkle-trees.md",sourceDirName:"overview",slug:"/overview/merkle-trees",permalink:"/overview/merkle-trees",draft:!1,editUrl:"https://github.com/project-illium/illium-documentation/docs/overview/merkle-trees.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Output Commitments",permalink:"/overview/output-commitments"},next:{title:"Lurk",permalink:"/overview/lurk"}},s={},c=[],p={toc:c},u="wrapper";function h(e){let{components:t,...a}=e;return(0,o.kt)(u,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"merkle-trees"},"Merkle Trees"),(0,o.kt)("p",null,"Bitcoin block headers contain a field called the ",(0,o.kt)("inlineCode",{parentName:"p"},"merkle root"),'. The merkle root is a compact cryptographic representation of\nthe transactions contained in the block. To build the tree the transactions are first hashed, then the hashes are paired\ntogether, concatenated, and hashed again. This process is repeated for each layer of the tree until you have a single "root"\nhash at the top of the tree as shown below.'),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Merkle-Tree-1",src:r(8944).Z,width:"1400",height:"585"})),(0,o.kt)("p",null,"A unique feature of the merkle tree is that it allows us to build compact inclusion proofs. For example, if I want to\nprove that transaction 6 is in the block, I could do so by providing you with the full list of transactions in the block.\nThat would work, you would see that, indeed, transaction 6 is in the block, but it's not very compact. Especially\nfor larger blocks. "),(0,o.kt)("p",null,"Using the merkle tree we can create a proof that is much more compact. In this case the proof would consist of:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The hash of transaction 5"),(0,o.kt)("li",{parentName:"ul"},"H78"),(0,o.kt)("li",{parentName:"ul"},"H1234")),(0,o.kt)("p",null,"From that information a verifier could compute ",(0,o.kt)("inlineCode",{parentName:"p"},"H56"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"H5678"),", and the ",(0,o.kt)("inlineCode",{parentName:"p"},"root")," hash. Then compare the root hash to the hash in\nthe block header. "),(0,o.kt)("p",null,"Illium also uses the exact same merkle tree to represent transactions in the block header, but in addition, at each block\nwe also calculate a merkle root of the entire set of transaction output commitments found in the entire blockchain. "),(0,o.kt)("p",null,"We call this the ",(0,o.kt)("inlineCode",{parentName:"p"},"Txoc Set Root")," (txoc stands for transaction output commitment)."),(0,o.kt)("p",null,"Recomputing the entire merkle tree every new block would be extremely resource intensive. Even more so when one considers\nthat the size of the txoc set is extremely large. Much larger than the number of transactions in a block. "),(0,o.kt)("p",null,"For this reason we use a variant of the Bitcoin merkle tree that is optimized for appends. We call this tree the ",(0,o.kt)("inlineCode",{parentName:"p"},"Txoc\nSet Accumulator"),"."),(0,o.kt)("p",null,"It works as follows. First, when we insert a new output commitment into the tree we prepend it with its index in the tree before\nhashing:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"hash := hash(index, outputCommitment)\n")),(0,o.kt)("p",null,"This ensures that each hash in the tree is unique, even if the output commitment is not. "),(0,o.kt)("p",null,"Now suppose we have four output commitments in the tree. It would look just like a normal merkle tree:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Merkle-Tree-2",src:r(1711).Z,width:"400",height:"277"})),(0,o.kt)("p",null,'If we were to add a fifth output commitment we would simply leave that output loose and treat it as its own separate "peak". '),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Merkle-Tree-3",src:r(6827).Z,width:"406",height:"227"})),(0,o.kt)("p",null,'Now we have a tree with two "peaks". We can compute the merkle root for the txoc set as the\nmerkle root of the set of peaks. In this case:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"root := hash(peak1, peak2)\n")),(0,o.kt)("p",null,"If we add a sixth output commitment the second tree grows in size:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Merkle-Tree-4",src:r(5255).Z,width:"493",height:"227"})),(0,o.kt)("p",null,"After a seventh output commitment we now have three peaks:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Merkle-Tree-5",src:r(610).Z,width:"608",height:"227"})),(0,o.kt)("p",null,"Again, we compute the txoc root by building a regular merkle tree out of the peaks:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"h1 := hash(peak1, peak2)\nh2 := hash(peak3, peak3) // As in bitcoin, an unpaired element gets hashed with itself.\nroot := hash(h1, h2)\n")),(0,o.kt)("p",null,"After adding an eighth output commitment into the tree, all the peaks merge back into a single peak:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Merkle-Tree-6",src:r(1171).Z,width:"1400",height:"585"})),(0,o.kt)("p",null,"So what we end up with is the number of peaks in the accumulator expands as the number of output commitments grows, but then\nat some point it collapses back to a single peak. Each round of expansion the number of peaks grows by one. Overall the number\nof peaks grows logarithmically with the number of output commitments. "),(0,o.kt)("p",null,"Additionally, full nodes only need to store the peaks on disk in order to update the accumulator and all the intermediate\nbranches can be deleted. So this accumulator uses very little disk space and very little CPU to update with each new block."),(0,o.kt)("p",null,"Just like the original merkle tree, we can still build compact inclusion proofs which we will need later to prove\nthat our transaction inputs are valid."))}h.isMDXComponent=!0},8944:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/Merkle-Tree-1-5750f929363a13660354367e8eeb7510.png"},1711:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/Merkle-Tree-2-de24943066dc7e28ca1214c334bc31a7.png"},6827:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/Merkle-Tree-3-40a1179871cc6f71baa1f5295f1f03c9.png"},5255:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/Merkle-Tree-4-57080bcd986098c1cb7aebb6286f592f.png"},610:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/Merkle-Tree-5-9d6c005cb261d75dd24a764fd73d723d.png"},1171:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/Merkle-Tree-6-f4cb191f1de568de9a561aa117810510.png"}}]);