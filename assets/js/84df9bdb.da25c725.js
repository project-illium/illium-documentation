"use strict";(self.webpackChunkillium_documentation=self.webpackChunkillium_documentation||[]).push([[1894],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>f});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),c=p(t),d=r,f=c["".concat(s,".").concat(d)]||c[d]||m[d]||l;return t?a.createElement(f,o(o({ref:n},u),{},{components:t})):a.createElement(f,o({ref:n},u))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,o=new Array(l);o[0]=d;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[c]="string"==typeof e?e:r,o[1]=i;for(var p=2;p<l;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},8860:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>i,toc:()=>p});var a=t(7462),r=(t(7294),t(3905));const l={sidebar_position:9,description:"Marco extensions"},o="Macros",i={unversionedId:"developers/macros",id:"developers/macros",title:"Macros",description:"Marco extensions",source:"@site/docs/developers/macros.md",sourceDirName:"developers",slug:"/developers/macros",permalink:"/docs/developers/macros",draft:!1,editUrl:"https://github.com/project-illium/illium-documentation/docs/developers/macros.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9,description:"Marco extensions"},sidebar:"devSidebar",previous:{title:"Lurk",permalink:"/docs/developers/lurk"},next:{title:"Deployment",permalink:"/docs/developers/deployment"}},s={},p=[{value:"Nesting",id:"nesting",level:2},{value:"Macro Definitions",id:"macro-definitions",level:2},{value:"Def",id:"def",level:3},{value:"Defrec",id:"defrec",level:3},{value:"Defun",id:"defun",level:3},{value:"Assert",id:"assert",level:3},{value:"Assert-eq",id:"assert-eq",level:3},{value:"List",id:"list",level:3},{value:"Param",id:"param",level:3},{value:"Import",id:"import",level:2}],u={toc:p},c="wrapper";function m(e){let{components:n,...t}=e;return(0,r.kt)(c,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"macros"},"Macros"),(0,r.kt)("p",null,"Lurk syntax can be difficult for read and write at times. Especially inside a lambda function where complex code often\nrequires many levels of nested expression. "),(0,r.kt)("p",null,"For this reason it's common for Lisp dialects to define a number of ",(0,r.kt)("inlineCode",{parentName:"p"},"macros")," that simplify the syntax and improve readability."),(0,r.kt)("p",null,"Ilxd offers a list of macros for this purpose. It should be noted that the following macros are ",(0,r.kt)("strong",{parentName:"p"},"NOT")," part of the\nLurk language. Rather ilxd has a ",(0,r.kt)("inlineCode",{parentName:"p"},"PreProcessor")," class that parses lurk code and expands the macros into pure lurk code."),(0,r.kt)("p",null,"When you commit to an unlocking function in illium, that function will always be pure lurk. If your code contains macros\nit will essentially be compiled into pure lurk before the commitment is made."),(0,r.kt)("h2",{id:"nesting"},"Nesting"),(0,r.kt)("p",null,"The macros defined here make it so that you can avoid the pattern of using many levels of nested expressions. Instead, the\nmacro preprocessor will handle the nesting when the macros are expanded into pure lurk. This is true even when multiple\nmacros are used  in succession and there are a number of levels of nesting."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(def x 3)\n!(def y 4)\n\n(+ x y)\n")),(0,r.kt)("p",null,"Macro expands into:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((x 3))\n     (let ((y 4))\n          (+ x y)\n     )\n)\n")),(0,r.kt)("p",null,"Evaluates to: ",(0,r.kt)("inlineCode",{parentName:"p"},"7")),(0,r.kt)("p",null,"You just need to make sure your unlocking function still returns ",(0,r.kt)("inlineCode",{parentName:"p"},"t")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"nil")," as the last expression. "),(0,r.kt)("h2",{id:"macro-definitions"},"Macro Definitions"),(0,r.kt)("h3",{id:"def"},"Def"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(def x 3)\n<expression>\n")),(0,r.kt)("p",null,"Macro expands to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((x 3))\n    <expression>\n)\n")),(0,r.kt)("h3",{id:"defrec"},"Defrec"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(defrec x 3)\n<expression>\n")),(0,r.kt)("p",null,"Macro expands to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(letrec ((x 3))\n    <expression>\n)\n")),(0,r.kt)("h3",{id:"defun"},"Defun"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(defun foo (x) (+ x 3))\n<expression>\n")),(0,r.kt)("p",null,"Macro expands to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(letrec ((foo (lambda (x) (+ x 3))))\n        <expression>\n)\n")),(0,r.kt)("h3",{id:"assert"},"Assert"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(assert (= 5 5))\n<expression>\n")),(0,r.kt)("p",null,"Macro expands to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(if (eq (= 5 5) nil)\n     nil\n     <expression>\n)\n")),(0,r.kt)("h3",{id:"assert-eq"},"Assert-eq"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(assert-eq (cons 1 2) (cons 1 2))\n<expression>\n")),(0,r.kt)("p",null,"Macro expands to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(if (eq (eq (cons 1 2) (cons 1 2)) nil)\n     nil\n     <expression>\n)\n")),(0,r.kt)("h3",{id:"list"},"List"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(list 1 2 3 4)\n")),(0,r.kt)("p",null,"Macro expands to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(cons 1 (cons 2 (cons 3 (cons 4 nil))))\n")),(0,r.kt)("h3",{id:"param"},"Param"),(0,r.kt)("p",null,"The param macro serves as a helpful shortcut for accessing the parameters of the unlocking function. It has multiple\nforms:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(param sighash)                                    \n!(param txo-root)                                     \n!(param fee)                                         \n!(param mint-id)                                     \n!(param mint-amount)                                 \n!(param locktime)                                     \n!(param locktime-precision)                           \n\n;; The below macros expand using the 'nth' function from\n;; the standard libary. As such this function will need\n;; to be imported if you use these macros.\n\n!(param nullifiers <index>)                           \n!(param pub-out <index>)                             \n!(param pub-out <index> commitment)                  \n!(param pub-out <index> ciphertext)                   \n\n!(param priv-in <index>)                              \n!(param priv-in <index> amount)                    \n!(param priv-in <index> asset-id)                                           \n!(param priv-in <index> salt)    \n!(param priv-in <index> state)           \n!(param priv-in <index> commitment-index             \n!(param priv-in <index> inclusion-proof) \n!(param priv-in <index> script) \n!(param priv-in <index> locking-params) \n!(param priv-in <index> unlocking-params)                \n\n!(param priv-out <index>)                            \n!(param priv-out <index> script-hash)                 \n!(param priv-out <index> amount)                     \n!(param priv-out <index> asset-id)                    \n!(param priv-out <index> state)                       \n!(param priv-out <index> salt)                      \n")),(0,r.kt)("h2",{id:"import"},"Import"),(0,r.kt)("p",null,"The preprocessor offers some limited package management facilities. Library files can be created with the form:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(module math (\n        !(defun plus-two (x) (+ x 2))\n        !(defun plus-three (x) (+ x 3))\n))\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Library files must use the ",(0,r.kt)("inlineCode",{parentName:"li"},".lurk")," file extension."),(0,r.kt)("li",{parentName:"ul"},"Library files may contain more than one module."),(0,r.kt)("li",{parentName:"ul"},"Modules must only make use of macros."),(0,r.kt)("li",{parentName:"ul"},"Modules may import other modules, but cannot do circular imports."),(0,r.kt)("li",{parentName:"ul"},"All top level functions and variables defined in the module are exported.")),(0,r.kt)("p",null,"The preprocessor takes in a dependency directory as an argument. The dependency directory may have sub-directories."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"/deps\n  |-- /std\n  |   |-- mod.lurk\n  |-- /utils\n  |   |-- mod.lurk\n")),(0,r.kt)("p",null,"Assume the ",(0,r.kt)("inlineCode",{parentName:"p"},"math")," module defined above was inside ",(0,r.kt)("inlineCode",{parentName:"p"},"/deps/std/mod.lurk"),", you can import the entire modules as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(import std/math)\n\n(plus-two (plus-three 5))\n")),(0,r.kt)("p",null,"Macro expands to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(letrec ((plus-two (lambda (x) (+ x 2))))\n        (letrec ((plus-three (lambda (x) (+ x 3))))\n                (plus-two (plus-three 5)) \n        )\n)\n")),(0,r.kt)("p",null,"Evaluates to: ",(0,r.kt)("inlineCode",{parentName:"p"},"10")),(0,r.kt)("p",null,"Alternatively, you can just import a single function from a module:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(import std/math/plus-two)\n\n(plus-two 5)\n")),(0,r.kt)("p",null,"Macro expands to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(letrec ((plus-two (lambda (x) (+ x 2))))\n        (plus-two 5) \n)\n")),(0,r.kt)("p",null,"Evaluates to: ",(0,r.kt)("inlineCode",{parentName:"p"},"7")),(0,r.kt)("p",null,"Keep in mind, if a function depends on another function in the module you'll need to import the entire\nmodule to use that function."))}m.isMDXComponent=!0}}]);