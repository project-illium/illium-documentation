"use strict";(self.webpackChunkillium_documentation=self.webpackChunkillium_documentation||[]).push([[7111],{3905:(t,e,n)=>{n.d(e,{Zo:()=>c,kt:()=>m});var a=n(7294);function i(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){i(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function r(t,e){if(null==t)return{};var n,a,i=function(t,e){if(null==t)return{};var n,a,i={},o=Object.keys(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||(i[n]=t[n]);return i}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(i[n]=t[n])}return i}var l=a.createContext({}),u=function(t){var e=a.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},c=function(t){var e=u(t.components);return a.createElement(l.Provider,{value:e},t.children)},h="mdxType",p={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},d=a.forwardRef((function(t,e){var n=t.components,i=t.mdxType,o=t.originalType,l=t.parentName,c=r(t,["components","mdxType","originalType","parentName"]),h=u(n),d=i,m=h["".concat(l,".").concat(d)]||h[d]||p[d]||o;return n?a.createElement(m,s(s({ref:e},c),{},{components:n})):a.createElement(m,s({ref:e},c))}));function m(t,e){var n=arguments,i=e&&e.mdxType;if("string"==typeof t||i){var o=n.length,s=new Array(o);s[0]=d;var r={};for(var l in e)hasOwnProperty.call(e,l)&&(r[l]=e[l]);r.originalType=t,r[h]="string"==typeof t?t:i,s[1]=r;for(var u=2;u<o;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1996:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>u});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:7},s="Data Messages",r={unversionedId:"api/data-messages",id:"api/data-messages",title:"Data Messages",description:"",source:"@site/docs/api/data-messages.md",sourceDirName:"api",slug:"/api/data-messages",permalink:"/api/data-messages",draft:!1,editUrl:"https://github.com/project-illium/illium-documentation/docs/api/data-messages.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"apiSidebar",previous:{title:"Node Service",permalink:"/api/node-service"},next:{title:"Notifications",permalink:"/api/notifications"}},l={},u=[],c={toc:u},h="wrapper";function p(t){let{components:e,...n}=t;return(0,i.kt)(h,(0,a.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"data-messages"},"Data Messages"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"message TransactionData {\n    oneof txids_or_txs {\n        // Just the transaction ID\n        bytes transaction_ID    = 1;\n        // A marshaled transaction.\n        Transaction transaction = 2;\n    }\n}\n\nmessage BlockInfo {\n    // The hash of the block header.\n    bytes  block_ID   = 1;\n    // A version number to track software/protocol upgrades.\n    uint32 version    = 2;\n    // The height of the block in the chain.\n    uint32 height     = 3;\n    // The block in the chain right before this one.\n    bytes parent      = 4;\n    // The next block in the chain (or nil if this block is the tip).\n    bytes child       = 5;\n    // The timestamp of the block. Expressed in seconds since 1970-01-01.\n    int64 timestamp   = 6;\n    // The root of the Merkle Tree built from all transactions in the block.\n    bytes tx_root     = 7;\n    // The peerID of the validator that created the block.\n    bytes producer_ID = 8;\n    // The size of the block in bytes.\n    uint32 size       = 9;\n    // The number of transactions in the block.\n    uint32 num_txs    = 10;\n}\n\nmessage Validator {\n    // The validator ID encoded in bytes.\n    bytes validator_ID     = 1;\n    // The number of coins staked by this validator in nanoillium.\n    uint64 total_stake     = 2;\n    // The total stake weighted by time lock in nanoillium.\n    uint64 stake_weight    = 3;\n    // The nullifiers for the utxos the validator has staked.\n    repeated Stake stake   = 4;\n    // The total of any unclaimed validator rewards in nanoillium.\n    uint64 unclaimed_coins = 5;\n    // The number of blocks this validator has created this epoch.\n    uint32 epoch_blocks    = 6;\n\n    message Stake {\n        // The nullifier that is staked\n        bytes nullifier           = 1;\n        // The amount staked in nanoillium\n        uint64 amount             = 2;\n        // The timestamp that this utxo is timelocked until\n        int64 timelocked_until    = 3;\n        // When this nullifier will expire and be removed from\n        // the validator set.\n        int64 expiration          = 4;\n        // The earliest date at which this nullifier can be restaked.\n        // One week before expiration.\n        int64 restake_eligibility = 5;\n    }\n}\n\nmessage Utxo {\n    // The commitment associated with the output\n    bytes commitment    = 1;\n    // The amount of coins in nanoillium\n    uint64 amount       = 2;\n    // The address that the utxo is associated with\n    string address      = 3;\n    // Whether or not this is a watch only utxo.\n    // We canot spend watch only utxos without the\n    // private key.\n    bool watchOnly      = 4;\n    // Is this utxo staked by the wallet.\n    bool staked         = 5;\n    // The timestamp this utxo is timelocked until (if applicable)\n    int64 locked_untill = 6;\n}\n\nmessage RawTransaction {\n    // The transaction as it appears on the network\n    Transaction tx                 = 1;\n    // The private (hidden) data for each input\n    repeated PrivateInput inputs   = 2;\n    // The private (hidden) data for each output\n    repeated PrivateOutput outputs = 3;\n}\n\nmessage PrivateInput {\n    // The amount of the input in nanoillium\n    uint64 amount                 = 1;\n    // Input asset ID\n    bytes asset_ID                = 2;\n    // Input salt\n    bytes salt                    = 3;\n    // Input state\n    bytes state                   = 4;\n    // The txo proof linking the input\n    // commitment to the accumulator\n    TxoProof txo_proof            = 5;\n    // The locking script\n    string script                 = 6;\n    // The locking function parameters\n    repeated bytes locking_params = 7;\n    // Optional lurk expression used as\n    // input to locking script. This is\n    // only necessary for watch-only utxos.\n    string unlocking_params       = 8;\n}\n\nmessage PrivateOutput {\n    // Output scriptHash\n    bytes script_hash = 1;\n    // Output amount in nanoillium\n    uint64 amount     = 2;\n    // Output salt\n    bytes salt        = 3;\n    // Output asset ID\n    bytes asset_ID    = 4;\n    // Output state\n    bytes state       = 5;\n}\n\nmessage TxoProof {\n    // The commitment this inclusion proof is for\n    bytes commitment      = 1;\n    // The hashes that form the root preimage\n    repeated bytes hashes = 2;\n    // Flags indicate whether a hash in the hash list is left or right.\n    // 0 == left, 1 == right.\n    uint64 flags          = 3;\n    // The index of this commitment in the tree\n    uint64 index          = 4;\n    // The txoRoot this proof links to. This is found in the block header.\n    bytes txoRoot         = 5;\n}\n\nmessage Peer {\n    // Peer ID\n    string id             = 1;\n    // The peer's user agent string\n    string user_agent     = 2;\n    // Multiaddrs\n    repeated string addrs = 3;\n}\n\nmessage WalletTransaction {\n    // Transaction ID\n    bytes transaction_ID        = 1;\n    // The net number of coins coming into the wallet in nanoillium\n    // Positive = receive\n    // Negative = send\n    int64 netCoins              = 2;\n    // The address and amount of each input if known\n    // to the wallet.\n    repeated IOMetadata inputs  = 3;\n    // The address and amount of each output if known\n    // to the wallet.\n    repeated IOMetadata outputs = 4;\n}\n\nmessage IOMetadata {\n    // Either address/amount information or unknown\n    // if input or output did not belong to this wallet\n    // and can't be decrypted.\n    oneof io_type {\n        TxIO tx_io      = 1;\n        Unknown unknown = 2;\n    }\n    \n    message TxIO {\n        // Address associated with the input or output\n        string address = 1;\n        // Amount of coins associated with the input or output in nanoillium\n        uint64 amount  = 2;\n    }\n    \n    // Represents an input or output not belonging to\n    // the wallet.\n    message Unknown {}\n}\n")))}p.isMDXComponent=!0}}]);