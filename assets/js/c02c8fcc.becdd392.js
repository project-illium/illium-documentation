"use strict";(self.webpackChunkillium_documentation=self.webpackChunkillium_documentation||[]).push([[5830],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var p=a.createContext({}),o=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=o(e.components);return a.createElement(p.Provider,{value:t},e.children)},c="mdxType",k={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,p=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=o(n),m=l,d=c["".concat(p,".").concat(m)]||c[m]||k[m]||i;return n?a.createElement(d,r(r({ref:t},u),{},{components:n})):a.createElement(d,r({ref:t},u))}));function d(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,r=new Array(i);r[0]=m;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[c]="string"==typeof e?e:l,r[1]=s;for(var o=2;o<i;o++)r[o]=n[o];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3365:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>k,frontMatter:()=>i,metadata:()=>s,toc:()=>o});var a=n(7462),l=(n(7294),n(3905));const i={sidebar_position:8,description:"Lurk language overview"},r="Lurk",s={unversionedId:"developers/lurk",id:"developers/lurk",title:"Lurk",description:"Lurk language overview",source:"@site/docs/developers/lurk.md",sourceDirName:"developers",slug:"/developers/lurk",permalink:"/docs/developers/lurk",draft:!1,editUrl:"https://github.com/project-illium/illium-documentation/docs/developers/lurk.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8,description:"Lurk language overview"},sidebar:"devSidebar",previous:{title:"Storage",permalink:"/docs/developers/storage"},next:{title:"Macros",permalink:"/docs/developers/macros"}},p={},o=[{value:"Lurk is Lisp",id:"lurk-is-lisp",level:2},{value:"Literals",id:"literals",level:3},{value:"Finite Fields",id:"finite-fields",level:3},{value:"Expressions",id:"expressions",level:3},{value:"Arithmetic Expressions",id:"arithmetic-expressions",level:3},{value:"Addition",id:"addition",level:4},{value:"Subtraction",id:"subtraction",level:4},{value:"Multiplication",id:"multiplication",level:4},{value:"Division",id:"division",level:4},{value:"Equals",id:"equals",level:4},{value:"Less than",id:"less-than",level:4},{value:"Greater than",id:"greater-than",level:4},{value:"Less than or equals",id:"less-than-or-equals",level:4},{value:"Greater than or equals",id:"greater-than-or-equals",level:4},{value:"Creating Variables",id:"creating-variables",level:3},{value:"Functions",id:"functions",level:3},{value:"Cons",id:"cons",level:3},{value:"Lists",id:"lists",level:3},{value:"If, Then, Else",id:"if-then-else",level:3},{value:"Builtins",id:"builtins",level:3},{value:"hash",id:"hash",level:4},{value:"nth",id:"nth",level:4},{value:"map-update",id:"map-update",level:4},{value:"map-get",id:"map-get",level:4},{value:"check-overflow",id:"check-overflow",level:4},{value:"Illium Unlocking Functions",id:"illium-unlocking-functions",level:3}],u={toc:o},c="wrapper";function k(e){let{components:t,...n}=e;return(0,l.kt)(c,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"lurk"},"Lurk"),(0,l.kt)("p",null,"All scripts are written in a language called Lurk. For a full technical documentation we'll point you some external\nresources:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://blog.lurk-lang.org/posts/circuit-spec/"},"The Lurk Circuit Specification")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/lurk-lab/user-manual"},"The Lurk User Manual"))),(0,l.kt)("h2",{id:"lurk-is-lisp"},"Lurk is Lisp"),(0,l.kt)("p",null,"Lurk is a dialect of Lisp and has a lot of commonalities with other Lisp dialects. Here we're going to cover everything\nyou need to write illium scripts in Lurk."),(0,l.kt)("h3",{id:"literals"},"Literals"),(0,l.kt)("p",null,"Literals are self-evaluating expressions. They include:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"num"),": a signed integer. Ex) 1 2 3, etc"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"u64"),": 64 bit unsigned integers"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"char"),": A character"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"comm"),": Represents a cryptographic commitment"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"nil"),": Represents a nil value or false"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"t"),": Represents true")),(0,l.kt)("h3",{id:"finite-fields"},"Finite Fields"),(0,l.kt)("p",null,"The underlying cryptography of Lurk makes use of finite fields. As such the largest number that can be represented by a ",(0,l.kt)("inlineCode",{parentName:"p"},"num"),"\nis "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"0x40000000000000000000000000000000224698fc0994a8dd8c46eb2100000001\n")),(0,l.kt)("p",null,"All arithmetic operations are conducted modulo this number. If your script relies on arithmetic operation performed on\nlarge numbers you'll need to take this into account. "),(0,l.kt)("p",null,"The range of possible values for num looks like:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"|-------------------------||--------------------------|\n0            most-positive\u2518\u2514most-negative      largest-unsigned\n")),(0,l.kt)("h3",{id:"expressions"},"Expressions"),(0,l.kt)("p",null,"Expression represent a piece of code or computation and usually (though not always) evaluate to a literal. "),(0,l.kt)("h3",{id:"arithmetic-expressions"},"Arithmetic Expressions"),(0,l.kt)("h4",{id:"addition"},"Addition"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(+ 3 5)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"8")),(0,l.kt)("h4",{id:"subtraction"},"Subtraction"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(- 3 5)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"-2")),(0,l.kt)("h4",{id:"multiplication"},"Multiplication"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(* 3 5)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"15")),(0,l.kt)("h4",{id:"division"},"Division"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(/ 15 5)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"3")),(0,l.kt)("h4",{id:"equals"},"Equals"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(= 7 7)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"t")),(0,l.kt)("h4",{id:"less-than"},"Less than"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(< 8 7)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"nil")),(0,l.kt)("h4",{id:"greater-than"},"Greater than"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(> 8 7)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"t")),(0,l.kt)("h4",{id:"less-than-or-equals"},"Less than or equals"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(<= 8 7)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"nil")),(0,l.kt)("h4",{id:"greater-than-or-equals"},"Greater than or equals"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(>= 8 7)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"t")),(0,l.kt)("h3",{id:"creating-variables"},"Creating Variables"),(0,l.kt)("p",null,"To create and assign variables you need to do so inside of a let expression. The let expression takes the form:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"(let <list of bindings> <expression>)\n")),(0,l.kt)("p",null,"Let's see what this looks like:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((x 3) (y 5)) (+ x y))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"8")),(0,l.kt)("p",null,"Take note of a couple things. First, the first argument is a ",(0,l.kt)("inlineCode",{parentName:"p"},"list")," of multiple variable assignments. Even if you\nonly intend to assign one variable, you still need to wrap the bindings in an extra parentheses. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((x 3)) x)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"3")),(0,l.kt)("p",null,"Second, the last argument to the let expression is an expression which makes use of the variables. The variables defined\ninside a let expression are only in scope for that expression and cannot be used outside of it. So typically you will\nmake use of the variables in the inner expression. "),(0,l.kt)("p",null,"Let expressions can be nested and the variables in the outer expression are in scope for the inner expression:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((x 3) (y 5))\n     (let ((z 10))\n          (* x z)))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"30")),(0,l.kt)("p",null,"When assigning new variables we can make use of variables defined earlier in the same let expression:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((x 3) \n      (y (+ x 20)))\n      y)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"23")),(0,l.kt)("p",null,"Later variables can shadow earlier ones:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((a 1)\n      (a 2))\n  a)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"2")),(0,l.kt)("p",null,"And inner variables can shadow outer ones:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((a 1))\n  (let ((a 2)) a))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"2")),(0,l.kt)("h3",{id:"functions"},"Functions"),(0,l.kt)("p",null,"Functions in lurk take the form of:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"(lambda <list of arguments> <body>)\n")),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(lambda (x) (+ x 1))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"function")),(0,l.kt)("p",null,"To call a function you need to create a ",(0,l.kt)("inlineCode",{parentName:"p"},"list")," (more on lists later) where the first element in the list is a function\nand the remaining elements are the function parameters."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"((lambda (x) (+ x 1)) 5)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"6")),(0,l.kt)("p",null,"Typically, you'll want to assign the function to a variable:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((my-func (lambda (x) \n                    (+ x 1))))\n     (my-func 10))    \n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"11")),(0,l.kt)("p",null,"Functions can have multiple arguments:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"((lambda (x y) (+ x y)) 3 5)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"8")),(0,l.kt)("p",null,"We can define recursive functions to execute loops but to do so we need to define them inside a ",(0,l.kt)("inlineCode",{parentName:"p"},"letrec")," expression\ninstead of a regular ",(0,l.kt)("inlineCode",{parentName:"p"},"let")," expression:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(letrec ((sum-upto (lambda (n) (if (= n 0)\n                                   0\n                                   (+ n (sum-upto (- n 1)))))))\n  (sum-upto 5))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"15")),(0,l.kt)("p",null,"Functions can receive other functions as inputs or emit functions as outputs:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(letrec ((map (lambda (f list)\n                (if (eq list nil)\n                    nil\n                    (cons (f (car list))\n                          (map f (cdr list))))))\n         (square (lambda (x) (* x x))))\n  (map square '(1 2 3 4 5)))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"(1 4 9 16 25)")),(0,l.kt)("h3",{id:"cons"},"Cons"),(0,l.kt)("p",null,"Cons cells are containers that hold two variables. They are created as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(cons 1 2)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"(1 . 2)")),(0,l.kt)("p",null,"(Note the . above is just notation to show this is a cons cell)"),(0,l.kt)("p",null,"Variables inside a cons cell can be accessed using the built-in ",(0,l.kt)("inlineCode",{parentName:"p"},"car")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"cdr")," functions. "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"car"),': returns the first element of the cons cell (The cons cell remains unchanged; This is not a "pop" operation).'),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"cdr"),": returns the last element of a cons cell.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((x (cons 1 2)))\n     (car x))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"1")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((x (cons 1 2)))\n     (cdr x))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"2")),(0,l.kt)("p",null,"Cons cells can be nested:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(cons 1 (cons 2 (cons 3 4)))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"(1 2 3 . 4)")),(0,l.kt)("p",null,"When you have a nested cons data structure, the ",(0,l.kt)("inlineCode",{parentName:"p"},"cdr")," function returns a ",(0,l.kt)("inlineCode",{parentName:"p"},"list")," of all the remaining nested elements."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((x (cons 1 (cons 2 (cons 3 4)))))\n     (cdr x))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"(2 3 . 4)")),(0,l.kt)("h3",{id:"lists"},"Lists"),(0,l.kt)("p",null,"We've already seen above that lists look like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"(x y z)\n")),(0,l.kt)("p",null,"However, we also mentioned above that lurk treats the first element in a list as a ",(0,l.kt)("inlineCode",{parentName:"p"},"function")," and tries to execute it.\nIn the above list, lurk would try to execute ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," as a function. If it was not a function, the script would error."),(0,l.kt)("p",null,"So how can we create a list in which the first element is not treated as a function?"),(0,l.kt)("p",null,"We create a nested cons structure, where the ",(0,l.kt)("em",{parentName:"p"},"last")," element of the last cons cell is ",(0,l.kt)("inlineCode",{parentName:"p"},"nil"),". "),(0,l.kt)("p",null,"For example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(cons 1 (cons 2 (cons 3 nil)))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"(1 2 3)")),(0,l.kt)("p",null,"Note there is a shorthand way of creating a list using the ",(0,l.kt)("inlineCode",{parentName:"p"},"quote")," operator."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(quote (1 2 3))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"(1 2 3)")),(0,l.kt)("p",null,"Or, even shorter:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"'(1 2 3)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"(1 2 3)")),(0,l.kt)("p",null,"However, be careful to avoid a pitfall here. The ",(0,l.kt)("inlineCode",{parentName:"p"},"quote")," operation will ",(0,l.kt)("strong",{parentName:"p"},"not")," evaluate any expression contained\nwithin the list."),(0,l.kt)("p",null,"Notice the following does ",(0,l.kt)("em",{parentName:"p"},"not")," evaluate to ",(0,l.kt)("inlineCode",{parentName:"p"},"(1 2 7)"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"'(1 2 (+ 3 4))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"(1 2 (+ 3 4))")," (essentially the raw data)"),(0,l.kt)("p",null,"If you want to make it evaluate the inner expression you can do:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(eval (car (cdr (cdr '(1 2 (+ 3 4))))))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"7")),(0,l.kt)("p",null,"Or just build out the list using the cons/nil format defined above."),(0,l.kt)("h3",{id:"if-then-else"},"If, Then, Else"),(0,l.kt)("p",null,"If expressions take the form:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(if <condition> <then_expression> <else_expression>)\n")),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(if (= 4 (+ 2 2))\n    t\n    (+ 9 7))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"t")),(0,l.kt)("p",null,"Non-nil expressions are treated as True in the conditional"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((x 3))\n     (if x\n         t\n         nil\n     )\n)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"t")),(0,l.kt)("p",null,"Finally, where ",(0,l.kt)("inlineCode",{parentName:"p"},"=")," tests the equality between integers, the ",(0,l.kt)("inlineCode",{parentName:"p"},"eq")," function tests the equality between expressions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(if (eq (cons 1 2) (cons 1 2))\n    t\n    (+ 9 7))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"t")),(0,l.kt)("h3",{id:"builtins"},"Builtins"),(0,l.kt)("p",null,"The following functions are not technically builtin functions in Lurk, however they are functions that are defined in\nthe illium validation program and thus are available to be used by unlocking script. Hence, they act like builtin functions."),(0,l.kt)("h4",{id:"hash"},"hash"),(0,l.kt)("p",null,"hash takes in a list of values, concatenates the values then returns the ",(0,l.kt)("inlineCode",{parentName:"p"},"blake2s")," hash of the concatenation.\nIf there is only one value in the list then the result is the hash of that single value."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(hash <list>)\n")),(0,l.kt)("p",null,"The following types are allowed in the list and are serialized as follows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"num"),": <32 bytes>"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"u64"),": <8 bytes>"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"char"),": <1 byte>")),(0,l.kt)("p",null,"Note: a variable can be cast to another type as so:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(u64 x)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," (type u64)"),(0,l.kt)("h4",{id:"nth"},"nth"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"(nth <index> <list>)\n")),(0,l.kt)("p",null,"nth returns the value in a list at a given index"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(nth 2 '(a b c d))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"c")),(0,l.kt)("h4",{id:"map-update"},"map-update"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"(map-update <key> <value> <map>)\n")),(0,l.kt)("p",null,"map-update inserts or updates the value for the given key in the map and returns the updated map. The map must be formatted as a flat list:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(:key0 value0 :key1 value1)\n")),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((m '(:k0 v0 :k1 v1)))\n     (map-update :k1 7 m))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"(:k0 v0 :k1 7)")),(0,l.kt)("h4",{id:"map-get"},"map-get"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"(map-get <key> <map>)\n")),(0,l.kt)("p",null,"map-get returns the value for the given key in the map. The map must be formatted as a flat list:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(:key0 value0 :key1 value1)\n")),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((m '(:k0 v0 :k1 v1)))\n     (map-get :k1 m))\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"v0")),(0,l.kt)("h4",{id:"check-overflow"},"check-overflow"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"(check-overflow <a> <b>)\n")),(0,l.kt)("p",null,"check-overflow returns true if a + b > max-u64. While the ",(0,l.kt)("inlineCode",{parentName:"p"},"num")," type supports integers much larger than 64 bits, the total\nnumber of illium coins does not exceed a u64 so it's important to verify no overflow is happening hen adding coin amounts."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(check-overflow 18446744073709551615 1)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"t")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(check-overflow 3 1)\n")),(0,l.kt)("p",null,"Evaluates to: ",(0,l.kt)("inlineCode",{parentName:"p"},"nil")),(0,l.kt)("h3",{id:"illium-unlocking-functions"},"Illium Unlocking Functions"),(0,l.kt)("p",null,"As we've already seen illium unlocking functions are ",(0,l.kt)("inlineCode",{parentName:"p"},"lambda")," expressions. The entire expression must evaluate\nto a ",(0,l.kt)("inlineCode",{parentName:"p"},"function")," and the body of the function ",(0,l.kt)("strong",{parentName:"p"},"must")," evaluate to either True or False (t or nil). Remember that ",(0,l.kt)("em",{parentName:"p"},"any"),"\nnon-nil return value will be treated at True."),(0,l.kt)("p",null,"Returns True"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(lambda (script-params unlocking-params input-index private-params public-params)\n    t\n)\n")),(0,l.kt)("p",null,"Also is True"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(lambda (script-params unlocking-params input-index private-params public-params)\n    7\n)\n")),(0,l.kt)("p",null,"Also is True"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(lambda (script-params unlocking-params input-index private-params public-params)\n    (cons 1 2)\n)\n")),(0,l.kt)("p",null,"Returns False"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(lambda (script-params unlocking-params input-index private-params public-params)\n    nil\n)\n")))}k.isMDXComponent=!0}}]);