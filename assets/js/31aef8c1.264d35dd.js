"use strict";(self.webpackChunkillium_documentation=self.webpackChunkillium_documentation||[]).push([[587],{3905:(t,e,n)=>{n.d(e,{Zo:()=>p,kt:()=>h});var a=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},o=Object.keys(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var u=a.createContext({}),l=function(t){var e=a.useContext(u),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},p=function(t){var e=l(t.components);return a.createElement(u.Provider,{value:e},t.children)},c="mdxType",d={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},m=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,o=t.originalType,u=t.parentName,p=s(t,["components","mdxType","originalType","parentName"]),c=l(n),m=r,h=c["".concat(u,".").concat(m)]||c[m]||d[m]||o;return n?a.createElement(h,i(i({ref:e},p),{},{components:n})):a.createElement(h,i({ref:e},p))}));function h(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var u in e)hasOwnProperty.call(e,u)&&(s[u]=e[u]);s.originalType=t,s[c]="string"==typeof t?t:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1978:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:11,description:"Security notes"},i="Security",s={unversionedId:"developers/security",id:"developers/security",title:"Security",description:"Security notes",source:"@site/docs/developers/security.md",sourceDirName:"developers",slug:"/developers/security",permalink:"/developers/security",draft:!1,editUrl:"https://github.com/project-illium/illium-documentation/docs/developers/security.md",tags:[],version:"current",sidebarPosition:11,frontMatter:{sidebar_position:11,description:"Security notes"},sidebar:"devSidebar",previous:{title:"Deployment",permalink:"/developers/deployment"}},u={},l=[{value:"Output Commitments",id:"output-commitments",level:3},{value:"State transitions",id:"state-transitions",level:3},{value:"Instance IDs",id:"instance-ids",level:3},{value:"Asset IDs",id:"asset-ids",level:3},{value:"Overflows",id:"overflows",level:3}],p={toc:l},c="wrapper";function d(t){let{components:e,...n}=t;return(0,r.kt)(c,(0,a.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"security"},"Security"),(0,r.kt)("p",null,"In this section we're going to highlight some important security considerations when building a smart contract. Remember,\nsmart contracts on illium work a little different from smart contracts on other platforms, so it's important to take\ncare when designing your contract and think through all the ways someone might try to attack it."),(0,r.kt)("h3",{id:"output-commitments"},"Output Commitments"),(0,r.kt)("p",null,"In order to spend an utxo in illium one needs to know the full preimage of the output commitment. Smart contracts are typically\nused by multiple parties who do not necessarily trust each other. It may be possible for one of those parties to set one\nof the preimage values to a value unknown to the other users of the contract, thus preventing all other parties from interacting\nwith the contract. "),(0,r.kt)("p",null,"How do we prevent this? We need to enforce covenants on the all the preimage fields that are unknown to all the users ensuring\nthat users are able to construct the full preimage. "),(0,r.kt)("p",null,"The output commitment preimage fields are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"script-hash"),": If this is a recursive script usually you'll enforce a covenant requiring this script-hash to be the same\nas the input script-hash."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"amount"),": You'll typically want to enforce that the contract's amount is computed correctly."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"asset-id"),": Don't forget to enforce the correct asset-id as this is one possible field that can be manipulated otherwise."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"salt"),": In normal transfers the salt is usually set to a random number generated by the sender. But if you let users of your\ncontract put any value here, then the value will be unknown to all other users. A good practice here is to require the salt be\nset to the hash of the input salt."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"state"),": Usually you'll be enforcing that the state is computed correctly.")),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(lambda (locking-params unlocking-params input-index private-params public-params)\n        !(import std/inputs/script-hash)\n        !(def new-amount (;; some code to compute the new amount here))\n        !(def new-state (;; some code to cmpute the new state here))\n\n        ;; Compute the required output\n        !(def required-output !(list\n                                (script-hash !(param priv-in input-index))\n                                new-amount\n                                !(param priv-in input-index asset-id)\n                                new-state\n                                (hash !(param priv-in input-index salt))))\n        \n        ;; Enforce covenant requring output 0 to be of the required form                  \n        !(assert-eq required-output !(param priv-out 0))\n        \n        t\n)\n")),(0,r.kt)("h3",{id:"state-transitions"},"State transitions"),(0,r.kt)("p",null,"As we talked about in the storage section, some contracts have a very large state that needs to be stored off chain with only\nthe root hash of the off-chain database stored in the contract. "),(0,r.kt)("p",null,"For these contracts in order to spend the utxo one not only needs to know the output commitment preimage, but also the private\nunlocking-parameters needed to update the off-chain database."),(0,r.kt)("p",null,"These parameters are not normally found in the contract, so it's up to you to enforce a covenant requiring they be put in the\ntransaction \u2015 typically in the ciphertext field."),(0,r.kt)("p",null,"The following contract adds new data to the contract storage and requires the data be included in the ciphertext."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(lambda (locking-params unlocking-params input-index private-params public-params)\n        !(import std/merkle-db)\n        !(import std/crypto/encrypt)\n        !(import std/inputs/script-hash)\n        \n        !(def new-amount (;; some code to compute the new amount here))\n        \n        ;; Adding new data to the state db\n        !(def data-to-store (car unlocking-params))\n        !(def merkle-proof (car (cdr unlocking-params))))\n        !(def new-state (db-put !(param priv-in input-index state) data-to-store merkle-proof))\n\n        ;; Compute the required output\n        !(def required-output !(list\n                                (script-hash !(param priv-in input-index))\n                                new-amount\n                                !(param priv-in input-index asset-id)\n                                new-state\n                                (hash !(param priv-in input-index salt))))\n        \n        ;; Enforce covenant requring output 0 to be of the required form                  \n        !(assert-eq required-output !(param priv-out 0))\n        \n        ;; Enforce  a covenant requring that the ciphertext contains (required-output data-to-store)\n        ;; and is encrypted with the hash of the input-salt. \n        !(assert-eq !(param pub-out 0 ciphertext) (encrypt !(list required-output data-to-store) (num (commit !(param priv-in input-index salt)))))\n        \n        t\n)\n")),(0,r.kt)("h3",{id:"instance-ids"},"Instance IDs"),(0,r.kt)("p",null,"When a smart contract wants to interact with another smart contract it's not sufficient to simply know the ",(0,r.kt)("inlineCode",{parentName:"p"},"script-hash"),"\nof the contract as that ",(0,r.kt)("inlineCode",{parentName:"p"},"script-hash")," could have multiple instances deployed on chain. You likely only want your contract\nto interact with one of those instances. "),(0,r.kt)("p",null,"To identify a specific instance of a contract we're going to need to encode an ",(0,r.kt)("inlineCode",{parentName:"p"},"instance-id")," in the state. And this\n",(0,r.kt)("inlineCode",{parentName:"p"},"instance-id")," should be encoded in such a way that it is unique to the contract and cannot be shared by other instances."),(0,r.kt)("p",null,"A good way to do this is to use the nullifier of the deployment transaction as the ",(0,r.kt)("inlineCode",{parentName:"p"},"instance-id")," as it's guaranteed to\nbe unique. "),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(lambda (script-params unlocking-params input-index private-params public-params)\n    !(def state !(param priv-in input-index state))\n    !(def instance-id (if (car state)\n                          (car state)\n                          !(param nullifiers input-index)))\n\n    !(def new-state !(list instance-id))\n)\n")),(0,r.kt)("h3",{id:"asset-ids"},"Asset IDs"),(0,r.kt)("p",null,"The transaction validation program only validates that:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The sum of ILX outputs plus the transaction fee <= the sum of the ILX inputs"),(0,r.kt)("li",{parentName:"ul"},"The sum of each unique output token <= the sum of each unique input token")),(0,r.kt)("p",null,"Thus, one might try to steal coins by attaching an input for a junk token and sending that token\nto the contract output. "),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Inputs\n======\n0: smart-contract, 100,000,000 (ILX)\n1: token, 100,000,000 (JUNK)\n\nOutputs\n=======\n0: smart-contract, 100,000,000 (JUNK)\n1: attacker-address, 100,000,000 (ILX)\n")),(0,r.kt)("p",null,"This transaction would pass the validation code since the input and output amounts balance. To prevent such an\nattack you need to enforce a covenant setting the asset-id for your contract output correctly."),(0,r.kt)("h3",{id:"overflows"},"Overflows"),(0,r.kt)("p",null,"Makes sure when working with any arithmetic operations you consider the possibility of overflows. As you do so\nkeep in mind that both ILX and token amounts cannot exceed a ",(0,r.kt)("inlineCode",{parentName:"p"},"u64")," even though lurk supports larger integers."))}d.isMDXComponent=!0}}]);